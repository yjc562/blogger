name: Blogger OAuth Token Automation
on:
  workflow_dispatch:

jobs:
  get-blogger-token:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # 确保安装所有依赖（含 webdriver-manager）
          pip install requests fastapi uvicorn python-dotenv selenium webdriver-manager

      - name: Create .env file
        run: |
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" >> .env
          echo "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}" >> .env
          echo "BLOGGER_SCOPES=${{ secrets.BLOGGER_SCOPES }}" >> .env
          echo "REDIRECT_URI=${{ secrets.REDIRECT_URI }}" >> .env

      - name: Start FastAPI OAuth Server
        run: |
          nohup uvicorn blogger_token:app --host 0.0.0.0 --port 8000 &
          sleep 15  # 延长等待时间，确保服务完全启动
          # 验证服务是否存活（新增）
          curl --fail --connect-timeout 5 http://localhost:8000 || (echo "服务启动失败" && exit 1)

      - name: Simulate OAuth Flow with Headless Browser（修复版）
        run: |
          python - << EOF
          from selenium import webdriver
          from selenium.webdriver.chrome.options import Options
          from selenium.webdriver.common.by import By
          from selenium.webdriver.support.ui import WebDriverWait
          from selenium.webdriver.support import expected_conditions as EC
          # 关键：自动安装并管理 Chrome 驱动（原脚本缺失）
          from webdriver_manager.chrome import ChromeDriverManager
          import time
          import requests

          # 优化 Chrome 配置（适配 GitHub Actions 环境）
          chrome_options = Options()
          chrome_options.add_argument("--headless=new")
          chrome_options.add_argument("--no-sandbox")
          chrome_options.add_argument("--disable-dev-shm-usage")
          chrome_options.add_argument("--window-size=1920,1080")  # 设置窗口大小，避免元素不可见
          chrome_options.add_argument("--disable-gpu")  # 禁用 GPU，减少资源占用

          # 自动安装驱动并启动 Chrome（核心修复）
          driver = webdriver.Chrome(
              executable_path=ChromeDriverManager().install(),
              options=chrome_options
          )
          driver.get("http://localhost:8000")
          print("已访问 FastAPI 首页，开始跳转 Google 登录页...")
          time.sleep(5)  # 等待跳转完成

          try:
              # 1. 定位并输入 Google 邮箱（优化定位方式，适配多语言）
              print("正在输入 Google 邮箱...")
              email_input = WebDriverWait(driver, 40).until(  # 延长超时时间到 40s
                  EC.element_to_be_clickable((By.XPATH, "//input[@type='email']"))  # 用 type 定位，更稳定
              )
              email_input.clear()
              email_input.send_keys("${{ secrets.GOOGLE_AUTH_EMAIL }}")
              # 点击“下一步”（用 XPath 定位，避免依赖 ID 变化）
              next_btn = WebDriverWait(driver, 20).until(
                  EC.element_to_be_clickable((By.XPATH, "//span[text()='下一步']"))
              )
              next_btn.click()
              time.sleep(8)  # 等待密码页加载

              # 2. 定位并输入 Google 密码
              print("正在输入 Google 密码...")
              password_input = WebDriverWait(driver, 40).until(
                  EC.element_to_be_clickable((By.XPATH, "//input[@type='password']"))
              )
              password_input.clear()
              password_input.send_keys("${{ secrets.GOOGLE_AUTH_PASSWORD }}")
              # 点击密码页“下一步”
              password_next_btn = WebDriverWait(driver, 20).until(
                  EC.element_to_be_clickable((By.XPATH, "//span[text()='下一步']"))
              )
              password_next_btn.click()
              time.sleep(12)  # 等待授权页加载（网络慢时需更长时间）

              # 3. 处理授权确认（若首次授权）
              print("正在确认授权...")
              try:
                  # 定位“允许”按钮（适配多语言，用包含文本匹配）
                  allow_btn = WebDriverWait(driver, 30).until(
                      EC.element_to_be_clickable((By.XPATH, "//button[contains(., '允许')]"))
                  )
                  allow_btn.click()
                  print("已点击允许授权")
                  time.sleep(8)
              except Exception as e:
                  print("无需二次授权（已授权过）或未找到允许按钮，错误：", str(e))

              # 4. 验证 Token 是否生成
              print("正在验证 Token 文件...")
              token_response = requests.get("http://localhost:8000/get_token", timeout=10)
              if token_response.status_code == 200:
                  print("✅ Token 获取成功！")
                  print("Token 有效期至：", token_response.json().get("expires_at"))
              else:
                  raise Exception(f"❌ Token 获取失败，状态码：{token_response.status_code}，响应：{token_response.text}")

          except Exception as main_e:
              print(f"授权流程出错：{str(main_e)}")
              print("当前页面源码（用于调试）：", driver.page_source[:2000])  # 打印部分源码，帮助定位问题
              raise  # 抛出错误，让工作流显示失败
          finally:
              driver.quit()
              print("浏览器已关闭")
          EOF

      - name: Upload Token File
        uses: actions/upload-artifact@v4
        with:
          name: blogger-token
          path: blogger_token.json
          retention-days: 7  # 设定产物保留7天，避免占用空间
